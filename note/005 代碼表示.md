
## [Challenges](https://craftinginterpreters.com/representing-code.html#challenges)

1. Earlier, I said that the `|`, `*`, and `+` forms we added to our grammar metasyntax were just syntactic sugar. Take this grammar:

	```
    expr → expr ( "(" ( expr ( "," expr )* )? ")" | "." IDENTIFIER )+
         | IDENTIFIER
         | NUMBER
	```

    Produce a grammar that matches the same language but does not use any of that notational sugar.
    
    _Bonus:_ What kind of expression does this bit of grammar encode?


Answer: this is very like a chain of property accesses and function calls, like

foo.bar(1, 2, 3...)(4, 5).xxx.yyy.func()...

```
expr → primary expr_rest ;

primary → IDENTIFIER ;
primary → NUMBER ;

expr_rest → call_or_property expr_rest ;
expr_rest → ε ;

call_or_property → call ;
call_or_property → property ;

call → "(" arguments ")" ;
property → "." IDENTIFIER ;

arguments → expr arguments_rest ;
arguments → ε ;

arguments_rest → "," expr arguments_rest ;
arguments_rest → ε ;
```
"ε" means "nothing", the chain ends here.
    
2. The Visitor pattern lets you emulate the functional style in an object-oriented language. Devise a complementary pattern for a functional language. It should let you bundle all of the operations on one type together and let you define new types easily.
    
    (SML or Haskell would be ideal for this exercise, but Scheme or another Lisp works as well.)

I don't understand this. Copilot said:

```scheme
;; Each expression is a record of functions
(define (make-literal n)
  (lambda (visitor)
    ((visitor 'literal) n)))

(define (make-add e1 e2)
  (lambda (visitor)
    ((visitor 'add) e1 e2)))

;; A visitor is a record of functions keyed by type
(define (eval-visitor)
  (lambda (type)
    (cond
      ((eq? type 'literal) (lambda (n) n))
      ((eq? type 'add) (lambda (e1 e2) (+ (e1 eval-visitor) (e2 eval-visitor))))))
```

Actually, in TypeScript, we can use type definition and pattern matching other than visitor pattern.

```typescript
type Expr =
  | { type: "literal"; value: number | string | boolean | null }
  | { type: "grouping"; expression: Expr }
  | { type: "unary"; operator: string; right: Expr }
  | { type: "binary"; left: Expr; operator: string; right: Expr };

function print(expr: Expr): string {
  switch (expr.type) {
    case "literal":
      return expr.value === null ? "nil" : String(expr.value);
    case "grouping":
      return `(group ${print(expr.expression)})`;
    case "unary":
      return `(${expr.operator} ${print(expr.right)})`;
    case "binary":
      return `(${expr.operator} ${print(expr.left)} ${print(expr.right)})`;
  }
}
```


3. In [reverse Polish notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation) (RPN), the operands to an arithmetic operator are both placed before the operator, so `1 + 2` becomes `1 2 +`. Evaluation proceeds from left to right. Numbers are pushed onto an implicit stack. An arithmetic operator pops the top two numbers, performs the operation, and pushes the result. Thus, this:
    
    (1 + 2) * (4 - 3)
    
    in RPN becomes:
    
    1 2 + 4 3 - *
    
    Define a visitor class for our syntax tree classes that takes an expression, converts it to RPN, and returns the resulting string.
    

Answer: see main2() in AstPrinter.ts