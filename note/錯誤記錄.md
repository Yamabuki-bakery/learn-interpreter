
## toString 關鍵字和 JS 衝突導致的

測試程序

```js
class Foo {
  getClosure() {
    fun closure() {
      return this.toString();
    }
    return closure;
  }

  toString() { return "Foo"; }
}

var closure = Foo().getClosure();
print closure(); // expect: Foo
```

症狀：Parser 沒法正確識別 this.toString，跟蹤發現 toString 的 token type 是一個。。。
![](file-20250926183023999.jpg)
問題出在 Scanner，檢查發現
![](file-20250926183245593.jpg)

懷疑當 text 是 toString 的時候，取得了 js 的 object 內置方法，而不是應該返回 undefined

將 keywords 從 Record（普通 object）改成 Map 解決：

```js
// ...existing code...
export class Scanner {
  private source: string;
  private tokens: Token[] = [];
  private start = 0;
  private current = 0;
  private line = 1;
  private keywords = new Map<string, TokenType>([
    ["and", TokenType.AND],
    ["class", TokenType.CLASS],
    ["else", TokenType.ELSE],
    ["false", TokenType.FALSE],
    ["for", TokenType.FOR],
    ["fun", TokenType.FUN],
    ["if", TokenType.IF],
    ["nil", TokenType.NIL],
    ["or", TokenType.OR],
    ["print", TokenType.PRINT],
    ["return", TokenType.RETURN],
    ["super", TokenType.SUPER],
    ["this", TokenType.THIS],
    ["true", TokenType.TRUE],
    ["var", TokenType.VAR],
    ["while", TokenType.WHILE],
    ["break", TokenType.BREAK],
    ["continue", TokenType.CONTINUE],
  ]);
// ...existing code...
  private identifier(): void {
    while (this.isAlphaNumeric(this.peek())) {
      this.advance();
    }
    const text = this.source.substring(this.start, this.current);
    const type = this.keywords.get(text) || TokenType.IDENTIFIER;
    this.addToken(type);
  }
// ...existing code...
```

## LoxNativeFunction 中，bind 不乾淨導致的

現象：

```javascript
var b = [10, 20, 30, "forty", ["fifty"]];
```

只會返回 

[10, 20, 30, "forty"]

但是

```javascript
var b = [10, 20, 30, "forty", []];
```

又可以正常返回

原因：
我在 Parser 中將 Array Literal 轉換成


```javascript
(fun () {
  var arr = Array();
  arr.push(1);
  arr.push(2);
  arr.push(3);
  ...
  return arr;
})()
```

如果有嵌套，就會變成

```javascript
var b = (fun (){
  var __arr = Array();
  __arr.push(10);
  __arr.push((fun (){
    var __brr = Array(); 
    __brr.push(20);
    return __brr;
  })());
  return __arr;
})();
```

原因就在於 brr 調用 push 的時候，我的 LoxNativeFunction 實現會將自己 rebind 到 brr 身上，等回到外層的 \_\_arr.push 的時候，push 的實際上是 brr，arr 根本沒動到

解決方法：不要 rebind，要直接生成一個新的 LoxNativeFunction 然後 bind 上 brr。

```javascript
  bind(instance: LoxInstance | LoxClass): LoxNativeFunction {
    // this.instance = instance;
    // return this;
    // Above is an error because this native Function can be re-bind by nested calls, and will lost the original instance after the nested calls returned.
    const bound = new LoxNativeFunction(this.name, this.arityGet, this.func);
    bound.instance = instance;
    return bound;
  }
```
