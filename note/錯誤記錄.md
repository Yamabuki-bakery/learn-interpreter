
## toString 關鍵字和 JS 衝突導致的

測試程序

```js
class Foo {
  getClosure() {
    fun closure() {
      return this.toString();
    }
    return closure;
  }

  toString() { return "Foo"; }
}

var closure = Foo().getClosure();
print closure(); // expect: Foo
```

症狀：Parser 沒法正確識別 this.toString，跟蹤發現 toString 的 token type 是一個。。。
![](file-20250926183023999.jpg)
問題出在 Scanner，檢查發現
![](file-20250926183245593.jpg)

懷疑當 text 是 toString 的時候，取得了 js 的 object 內置方法，而不是應該返回 undefined

將 keywords 從 Record（普通 object）改成 Map 解決：

```js
// ...existing code...
export class Scanner {
  private source: string;
  private tokens: Token[] = [];
  private start = 0;
  private current = 0;
  private line = 1;
  private keywords = new Map<string, TokenType>([
    ["and", TokenType.AND],
    ["class", TokenType.CLASS],
    ["else", TokenType.ELSE],
    ["false", TokenType.FALSE],
    ["for", TokenType.FOR],
    ["fun", TokenType.FUN],
    ["if", TokenType.IF],
    ["nil", TokenType.NIL],
    ["or", TokenType.OR],
    ["print", TokenType.PRINT],
    ["return", TokenType.RETURN],
    ["super", TokenType.SUPER],
    ["this", TokenType.THIS],
    ["true", TokenType.TRUE],
    ["var", TokenType.VAR],
    ["while", TokenType.WHILE],
    ["break", TokenType.BREAK],
    ["continue", TokenType.CONTINUE],
  ]);
// ...existing code...
  private identifier(): void {
    while (this.isAlphaNumeric(this.peek())) {
      this.advance();
    }
    const text = this.source.substring(this.start, this.current);
    const type = this.keywords.get(text) || TokenType.IDENTIFIER;
    this.addToken(type);
  }
// ...existing code...
```